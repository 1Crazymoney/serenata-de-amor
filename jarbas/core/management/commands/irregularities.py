import csv
import lzma
import os
import concurrent.futures

from jarbas.core.management.commands import LoadCommand
from jarbas.core.models import Reimbursement


class Command(LoadCommand):
    help = 'Load Serenata de Amor irregularities dataset'
    count = 0
    filter_keys = ('applicant_id', 'document_id', 'year')

    def add_arguments(self, parser):
        super().add_arguments(parser, add_drop_all=False)

    def handle(self, *args, **options):
        self.path = options['dataset']
        if not os.path.exists(self.path):
            raise FileNotFoundError(os.path.abspath(self.path))

        self.main()
        print('{:,} reimbursements updated.'.format(self.count))

    def irregularities(self):
        """Returns a Generator with a irregularities for each reimbursement."""
        print('Loading irregularities dataset…')
        with lzma.open(self.path, mode='rt') as file_handler:
            for row in csv.DictReader(file_handler):
                yield self.serialize(row)

    def serialize(self, row):
        """
        Read the dict generated by DictReader and return a tuple with two
        dictionaries, one to be used as filter to locate the reimbursement,
        another one with data from the irregularities.
        """

        unique_id = dict()
        for key in self.filter_keys:
            unique_id[key] = int(row[key])
            del row[key]

        probability = None
        if 'probability' in row:
            probability = float(row['probability'])
            del row['probability']

        suspicions = {k: self.to_bool(v) for k, v in row.items()}

        return unique_id, dict(probability=probability, suspicions=suspicions)

    @staticmethod
    def to_bool(string):
        if string in ('False', '0'):
            string = ''
        return bool(string)

    def main(self):
        with concurrent.futures.ThreadPoolExecutor(max_workers=16) as executor:
            print('Preparing updates…', end='\r')
            for result in executor.map(self.update, self.irregularities()):
                self.count += 1
                msg = '{:,} reimbursements updated.'
                print(msg.format(self.count), end='\r')

    def update(self, dict_tuple):
        filters, content = dict_tuple
        Reimbursement.objects.filter(**filters).update(**content)
