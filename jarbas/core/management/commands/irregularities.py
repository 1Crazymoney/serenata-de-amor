import csv
import lzma
import os
import concurrent.futures

from jarbas.core.management.commands import LoadCommand
from jarbas.core.models import Reimbursement


class Command(LoadCommand):
    help = 'Load Serenata de Amor irregularities dataset'
    count = 0
    filter_keys = ('applicant_id', 'document_id', 'year')

    def add_arguments(self, parser):
        parser.add_argument(
            '--irregularities', '-i', dest='irregularities_path',
            default='irregularities.xz',
            help='Path to the irregularities.xz dataset'
        )

    def handle(self, *args, **options):
        self.path = options.get('irregularities_path', 'irregularities.xz')
        if not os.path.exists(self.path):
            raise FileNotFoundError(os.path.abspath(self.path))

        self.main()
        print('{:,} reimbursements updated.'.format(self.count))

    @property
    def irregularities(self):
        """Returns a Generator with a irregularities for each reimbursement."""
        print('Loading irregularities dataset…')
        with lzma.open(self.path, mode='rt') as file_handler:
            for row in csv.DictReader(file_handler):
                yield self.serialize(row)

    def serialize(self, row):
        """
        Read the dict generated by DictReader and return two dictionaries, one
        to be used as filter to locate the reimbursement, another one with data
        from the irregularities.
        """

        unique_id = dict()
        for key in self.filter_keys:
            unique_id[key] = int(row[key])
            del row[key]

        probability = None
        if 'probability' in row:
            probability = float(row['probability'])
            del row['probability']

        suspicions = {k: self.to_bool(v) for k, v in row.items()}

        return unique_id, dict(probability=probability, suspicions=suspicions)

    @staticmethod
    def to_bool(string):
        if string in ('False', '0'):
            string = ''
        return bool(string)

    def main(self):
        with concurrent.futures.ThreadPoolExecutor(max_workers=16) as executor:
            futures = dict(
                (executor.submit(self.update, filters, content), filters)
                for filters, content in self.irregularities
            )
            print('Preparing updates…')
            for future in concurrent.futures.as_completed(futures):
                obj = futures[future]
                if future.exception():
                    print('{} raised an exception: {}'.format(obj,  future.exception()))
                else:
                    self.count += 1
                    print('{:,} reimbursements updated.'.format(self.count), end='\r')

    @staticmethod
    def update(filters, content):
        return Reimbursement.objects.filter(**filters).update(**content)
