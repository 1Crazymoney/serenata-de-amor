import csv
import lzma
from tempfile import NamedTemporaryFile
from urllib.request import urlretrieve

from django.conf import settings
from django.core.management.base import BaseCommand

from jarbas.core.models import Document


class Command(BaseCommand):
    help = 'Load Serenata de Amor datasets into the database'
    loaded = 0

    def add_arguments(self, parser):
        parser.add_argument(
            '--start', '-s', dest='start', default=None, type=int,
            help='Where the load should start (skips first LIMIT documents)'
        )
        parser.add_argument(
            '--limit', '-l', dest='limit', default=None, type=int,
            help='Limit the number of documents to load'
        )
        parser.add_argument(
            '--drop-documents', '-d', dest='drop', action='store_true',
            help='Drop all existing documents before loading the dataset'
        )

    def documents(self):
        """Load datasets and return a dict similar to model Document"""
        suffixes = ('current-year', 'last-year', 'previous-years')
        for suffix in suffixes:
            url = self.get_url(suffix)
            print("Loading " + url)
            with NamedTemporaryFile() as tmp:
                urlretrieve(url, filename=tmp.name)
                with lzma.open(tmp.name, mode='rt') as file_handler:
                    for index, row in enumerate(csv.DictReader(file_handler)):
                        row['source'] = suffix
                        row['line'] = index + 1
                        yield row

    def selected_documents(self, start, limit):
        documents = map(self.serialize, self.documents())
        for count, document in enumerate(documents):
            after_start = not start or count > start
            reached_limit = limit and self.loaded >= limit
            if after_start and not reached_limit:
                self.loaded += 1
                yield document
            elif reached_limit:
                break

    def handle(self, *args, **options):
        """Create or update records (if they match `document_id`)"""
        print('Started with {:,} document'.format(Document.objects.count()))

        if options.get('drop', False):
            self.drop_documents()

        documents = self.selected_documents(options['start'], options['limit'])
        Document.objects.bulk_create(Document(**doc) for doc in documents)
        print('Now we have {:,} document'.format(Document.objects.count()))

    def serialize(self, document):
        """Read the dict generated by DictReader and fix content types"""
        integers = (
            'document_id',
            'congressperson_id',
            'congressperson_document',
            'term',
            'term_id',
            'subquota_number',
            'subquota_group_id',
            'document_type',
            'month',
            'year',
            'installment',
            'batch_number',
            'reimbursement_number',
            'applicant_id'
        )
        for key in integers:
            document[key] = self.to_number(document[key], int)

        floats = (
            'document_value',
            'remark_value',
            'net_value',
            'reimbursement_value'
        )
        for key in floats:
            document[key] = self.to_number(document[key], float)

        if document['issue_date'] == '':
            document['issue_date'] = None

        return document

    @staticmethod
    def drop_documents():
        print('Deleting all existing documents')
        Document.objects.all().delete()
        print('Now we have {:,} document'.format(Document.objects.count()))

    @staticmethod
    def get_url(suffix):
        file_name = '{date}-{suffix}.xz'.format(
            date=settings.AMAZON_S3_DATASET_DATE,
            suffix=suffix
        )
        url = 'https://{region}.amazonaws.com/{bucket}/{file_name}'.format(
            region=settings.AMAZON_S3_REGION,
            bucket=settings.AMAZON_S3_BUCKET,
            file_name=file_name
        )
        return url

    @staticmethod
    def to_number(value, type_of_number):
        if type_of_number == int:
            type_of_number = lambda x: int(float(x))
        return 0 if value in ('NaN', '') else type_of_number(value)
