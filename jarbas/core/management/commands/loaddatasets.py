import csv
import lzma
import os
import re

from jarbas.core.management.commands import LoadCommand
from jarbas.core.models import Document


class Command(LoadCommand):
    help = 'Load Serenata de Amor datasets into the database'
    suffixes = ('current-year', 'last-year', 'previous-years')

    def add_arguments(self, parser):
        super().add_arguments(parser)
        parser.add_argument(
            '--batch-size', '-b', dest='batch_size', type=int, default=10000,
            help='Number of documents to be created at a time (default: 10000)'
        )

    def handle(self, *args, **options):
        print('Starting with {:,} documents'.format(Document.objects.count()))

        if options.get('drop', False):
            self.drop_all(Document)

        source = options['source']
        datasets = self.load_local(source) if source else self.load_remote()
        documents = self.documents_from(datasets)
        self.bulk_create_by(documents, options['batch_size'])

    def documents_from(self, datasets):
        """
        Receives a generator with the path to the dataset files and returns a
        Document object for each row of each file.
        """
        for dataset in datasets:
            with lzma.open(dataset, mode='rt') as file_handler:
                for index, row in enumerate(csv.DictReader(file_handler)):
                    row['source'] = self.get_suffix(dataset)
                    row['line'] = index + 1
                    yield Document(**self.serialize(row))

    def load_local(self, source):
        for name in self.suffixes:
            yield super().load_local(source, name)

    def load_remote(self):
        for name in self.suffixes:
            yield super().load_remote(name)

    def serialize(self, document):
        """Read the dict generated by DictReader and fix content types"""
        integers = (
            'document_id',
            'congressperson_id',
            'congressperson_document',
            'term',
            'term_id',
            'subquota_number',
            'subquota_group_id',
            'document_type',
            'month',
            'year',
            'installment',
            'batch_number',
            'reimbursement_number',
            'applicant_id'
        )
        for key in integers:
            document[key] = self.to_number(document[key], int)

        floats = (
            'document_value',
            'remark_value',
            'net_value',
            'reimbursement_value'
        )
        for key in floats:
            document[key] = self.to_number(document[key], float)

        if document['issue_date'] == '':
            document['issue_date'] = None

        return document

    def bulk_create_by(self, documents, size):
        batch = list()
        for document in documents:
            batch.append(document)
            if len(batch) == size:
                Document.objects.bulk_create(batch)
                batch = list()
                self.print_count(Document)
        Document.objects.bulk_create(batch)
        self.print_count(Document, permanent=True)

    def to_number(self, value, type_of_number):
        if value in ('NaN', ''):
            return 0

        if type_of_number == int:
            type_of_number = self.force_int

        return type_of_number(value)

    @staticmethod
    def force_int(number):
        """Helps converting strings like '1.0' to integer"""
        return int(float(number))

    @staticmethod
    def get_suffix(path):
        regex = r'^[\d-]{11}(current-year|last-year|previous-years).xz$'
        name = os.path.basename(path)
        match = re.compile(regex).match(name)
        if match:
            return match.group(1)
